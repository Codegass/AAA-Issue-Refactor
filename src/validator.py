"""Code validation and integration utilities."""

import re
import subprocess
from pathlib import Path
from typing import Optional, Tuple, List
import logging

logger = logging.getLogger('aif')

class CodeValidator:
    """Validates and integrates refactored code."""
    
    def __init__(self, java_project_path: Path):
        self.java_project_path = java_project_path
    
    def integrate_refactored_method(
        self,
        test_file_path: Path,
        original_method_name: str,
        refactored_code: str,
        strategy: str,
        additional_imports: Optional[List[str]] = None,
        is_one_to_many: bool = False,
        debug_mode: bool = False
    ) -> Tuple[bool, str, List[int]]:
        """
        Integrates refactored code into the original test file non-destructively.

        - Adds new imports.
        - Appends the refactored method(s) to the class.
        - If it's a one-to-one refactoring, the original method is commented out.
        - If it's a one-to-many refactoring (e.g., splitting a test), the original method is deleted.

        Args:
            test_file_path: Path to the Java test file.
            original_method_name: The name of the method that was refactored.
            refactored_code: The new code generated by the LLM.
            strategy: The refactoring strategy used (e.g., 'aaa', 'dsl').
            additional_imports: A list of new imports to add.
            is_one_to_many: True if one method was split into multiple.
            debug_mode: True if debug mode is enabled.

        Returns:
            A tuple containing:
            - bool: Success or failure.
            - str: The updated content of the file.
            - List[int]: A list of line numbers where code was inserted.
        """
        try:
            original_content = test_file_path.read_text(encoding='utf-8')
            modified_content = original_content
            
            # Step 1: Add new imports if any
            if additional_imports:
                modified_content, success = self._add_imports(modified_content, additional_imports)
                if not success:
                    logger.warning(f"  Could not add new imports to '{test_file_path}'.")

            # Step 2: Handle the original method (comment or delete)
            if is_one_to_many:
                # For one-to-many, we delete the original method entirely
                modified_content, success = self._delete_method(modified_content, original_method_name)
                if not success:
                    logger.error(f"  Could not find and delete original method '{original_method_name}' for one-to-many refactoring.")
                    return False, original_content, []
            else:
                # For one-to-one, we find and comment out the original method
                modified_content, success = self._comment_out_method(modified_content, original_method_name)
                if not success:
                    logger.warning(f"  Could not find and comment out original method '{original_method_name}'. It may have been modified or removed.")

            # Step 3: Prepare the new code block for insertion
            separator_start = f"// --- Start Refactored by {strategy} from {original_method_name} ---"
            separator_end = f"// --- End Refactored by {strategy} ---"
            code_to_insert = f"\n{separator_start}\n{refactored_code}\n{separator_end}\n"

            # Step 4: Find the insertion point (the closing brace of the class)
            lines = modified_content.split('\n')
            insertion_line = self._find_class_closing_brace(lines)
            if insertion_line == -1:
                logger.error(f"  Could not find class closing brace in '{test_file_path}'.")
                return False, original_content, []
            
            # Insert the new code block before the class's closing brace
            lines.insert(insertion_line, code_to_insert)
            final_content = '\n'.join(lines)
            
            if debug_mode:
                logger.debug("\n--- Code Validator: Final Content to be Written ---")
                logger.debug(f"File: {test_file_path}")
                logger.debug(f"---\n{final_content}\n---")
                logger.debug("--------------------------------------------------\n")

            # Track inserted lines (simple approach: start and end of insertion)
            inserted_lines_range = list(range(insertion_line, insertion_line + code_to_insert.count('\n')))

            return True, final_content, inserted_lines_range

        except Exception as e:
            logger.error(f"Error integrating refactored method: {e}", exc_info=True)
            return False, original_content, []
    
    def _add_imports(self, content: str, new_imports: List[str]) -> Tuple[str, bool]:
        """Adds new import statements to the Java source code content."""
        lines = content.split('\n')
        
        # Find existing imports
        existing_imports = {line.strip() for line in lines if line.strip().startswith("import ")}
        last_import_line_idx = -1
        package_declaration_idx = -1

        for i, line in enumerate(lines):
            if line.strip().startswith("import "):
                last_import_line_idx = i
            if line.strip().startswith("package "):
                package_declaration_idx = i
        
        # Determine where to insert new imports
        insertion_point = -1
        if last_import_line_idx != -1:
            insertion_point = last_import_line_idx + 1
        elif package_declaration_idx != -1:
            insertion_point = package_declaration_idx + 1
        else:
            # Fallback: insert at the top (after potential license headers)
            for i, line in enumerate(lines):
                if not line.strip().startswith(("/*", "*", "*/", "//")):
                    insertion_point = i
                    break
            if insertion_point == -1: insertion_point = 0

        # Add new imports that don't already exist
        added_count = 0
        for imp in reversed(new_imports):
            full_import_statement = f"import {imp};"
            if full_import_statement not in existing_imports:
                lines.insert(insertion_point, full_import_statement)
                added_count += 1
        
        return '\n'.join(lines), True
    
    def _find_method_span(self, lines: List[str], method_name: str) -> Tuple[int, int]:
        """Finds the start and end line numbers of a method, including its annotations."""
        method_line_idx = -1
        # A simple regex to find method declarations, ignoring complex cases for now
        method_pattern = re.compile(r'\b' + re.escape(method_name) + r'\s*\(')

        for i, line in enumerate(lines):
            if method_pattern.search(line):
                method_line_idx = i
                break
        
        if method_line_idx == -1:
            logger.debug(f"Could not find method declaration for '{method_name}'")
            return -1, -1

        # Find the start of the method's annotations by looking backwards
        start_line = method_line_idx
        for i in range(method_line_idx - 1, -1, -1):
            line = lines[i].strip()
            # Stop if we hit something that's clearly not an annotation or comment
            if line and not line.startswith("@") and not line.startswith("/*") and not line.startswith("*"):
                break
            start_line = i
        
        # Find the end of the method using brace counting
        brace_count = 0
        end_line = -1
        in_method_body = False
        for i in range(method_line_idx, len(lines)):
            line = lines[i]
            if '{' in line:
                if not in_method_body:
                    # This is the start of the body
                    in_method_body = True
                brace_count += line.count('{')
            
            if '}' in line and in_method_body:
                brace_count -= line.count('}')
            
            if in_method_body and brace_count == 0:
                end_line = i
                break
        
        return start_line, end_line

    def _comment_out_method(self, content: str, method_name: str) -> Tuple[str, bool]:
        """Comments out a method and its preceding annotations."""
        lines = content.split('\n')
        start_line, end_line = self._find_method_span(lines, method_name)
        
        if start_line == -1 or end_line == -1:
            logger.debug(f"Could not comment out method '{method_name}': span not found.")
            return content, False

        for i in range(start_line, end_line + 1):
            lines[i] = "// " + lines[i]
            
        return '\n'.join(lines), True

    def _delete_method(self, content: str, method_name: str) -> Tuple[str, bool]:
        """Deletes a method and its preceding annotations from the given source code content."""
        lines = content.split('\n')
        start_line, end_line = self._find_method_span(lines, method_name)
        
        if start_line == -1 or end_line == -1:
            logger.debug(f"Could not delete method '{method_name}': span not found.")
            return content, False # Method not found
        
        del lines[start_line : end_line + 1]
        return '\n'.join(lines), True
    
    def _find_class_closing_brace(self, lines: List[str]) -> int:
        """Find the insertion point: the line index of the class's last closing brace."""
        # A simple heuristic: find the last '}' that is not at the start of the line
        # This avoids matching method closing braces in most simple cases.
        # A more robust solution would parse the class structure.
        for i in range(len(lines) - 1, -1, -1):
            if lines[i].strip() == '}':
                return i
        return -1
    
    def compile_java_project(self) -> Tuple[bool, str]:
        """Compile the Java project to check for syntax errors."""
        try:
            # Try Maven first
            if (self.java_project_path / "pom.xml").exists():
                result = subprocess.run(
                    ["mvn", "clean", "compile", "test-compile", "-Drat.skip=true"],
                    cwd=self.java_project_path,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                return result.returncode == 0, result.stderr
            
            # Try Gradle
            elif (self.java_project_path / "build.gradle").exists() or (self.java_project_path / "build.gradle.kts").exists():
                result = subprocess.run(
                    ["./gradlew", "clean", "compileJava", "compileTestJava"],
                    cwd=self.java_project_path,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                return result.returncode == 0, result.stderr
            
            else:
                return False, "No Maven pom.xml or Gradle build file found"
                
        except subprocess.TimeoutExpired:
            return False, "Compilation timeout"
        except Exception as e:
            return False, f"Compilation error: {str(e)}"
    
    def run_specific_test(self, test_class: str, test_method: str) -> Tuple[bool, str]:
        """Run a specific test method."""
        try:
            # Try Maven first
            if (self.java_project_path / "pom.xml").exists():
                test_spec = f"{test_class}#{test_method}"
                command = [
                    "mvn", "surefire:test", 
                    f"-Dtest={test_spec}", 
                    "-DfailIfNoTests=false",
                    "-Dmaven.test.failure.ignore=true",
                    "-Drat.skip=true"
                ]
                result = subprocess.run(
                    command,
                    cwd=self.java_project_path,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                
                output = result.stdout + result.stderr
                # A successful BUILD is the first gate. Real pass/fail is checked next.
                if "BUILD SUCCESS" not in output:
                    return False, output

                # Check for actual test results
                # Example: Tests run: 1, Failures: 0, Errors: 0
                match = re.search(r'Tests run: (\d+), Failures: (\d+), Errors: (\d+)', output)
                if match:
                    runs, failures, errors = map(int, match.groups())
                    if runs > 0 and failures == 0 and errors == 0:
                        return True, output  # Test ran and passed

                return False, output # Test failed, had errors, or did not run
            
            # Try Gradle
            elif (self.java_project_path / "build.gradle").exists() or (self.java_project_path / "build.gradle.kts").exists():
                test_spec = f"{test_class}.{test_method}"
                result = subprocess.run(
                    ["./gradlew", "test", f"--tests", test_spec],
                    cwd=self.java_project_path,
                    capture_output=True,
                    text=True,
                    timeout=300
                )
                return result.returncode == 0, result.stdout + result.stderr
            
            else:
                return False, "No Maven pom.xml or Gradle build file found"
                
        except subprocess.TimeoutExpired:
            return False, "Test execution timeout"
        except Exception as e:
            return False, f"Test execution error: {str(e)}"