"""Code validation and integration utilities."""

import re
import subprocess
from pathlib import Path
from typing import Optional, Tuple, List
import logging

from .build_system import create_build_system, BuildSystem

logger = logging.getLogger('aif')

class CodeValidator:
    """Validates and integrates refactored code."""
    
    def __init__(self, java_project_path: Path):
        self.java_project_path = java_project_path
        self.build_system = create_build_system(java_project_path)
        
        logger.debug(f"Initialized CodeValidator with {self.build_system.get_build_system_name()} build system")
    
    def integrate_refactored_method(
        self,
        test_file_path: Path,
        original_method_name: str,
        refactored_code: str,
        strategy: str,
        additional_imports: Optional[List[str]] = None,
        is_one_to_many: bool = False,
        debug_mode: bool = False
    ) -> Tuple[bool, str, List[int]]:
        """
        Integrates refactored code into the original test file non-destructively.

        - Adds new imports.
        - For one-to-one refactoring: comments out the original method and inserts refactored code right after it.
        - For one-to-many refactoring: deletes the original method and inserts refactored code at the same location.

        Args:
            test_file_path: Path to the Java test file.
            original_method_name: The name of the method that was refactored.
            refactored_code: The new code generated by the LLM.
            strategy: The refactoring strategy used (e.g., 'aaa', 'dsl').
            additional_imports: A list of new imports to add.
            is_one_to_many: True if one method was split into multiple.
            debug_mode: True if debug mode is enabled.

        Returns:
            A tuple containing:
            - bool: Success or failure.
            - str: The updated content of the file.
            - List[int]: A list of line numbers where code was inserted.
        """
        try:
            original_content = test_file_path.read_text(encoding='utf-8')
            modified_content = original_content
            
            # Step 1: Add new imports if any
            if additional_imports:
                modified_content, success = self._add_imports(modified_content, additional_imports)
                if not success:
                    logger.warning(f"  Could not add new imports to '{test_file_path}'.")

            # Step 2: Find the original method location first
            lines = modified_content.split('\n')
            start_line, end_line = self._find_method_span(lines, original_method_name)
            
            if start_line == -1 or end_line == -1:
                logger.error(f"  Could not find original method '{original_method_name}' in the file.")
                return False, original_content, []

            # Step 3: Prepare the new code block for insertion
            separator_start = f"// --- Start Refactored by {strategy} from {original_method_name} ---"
            separator_end = f"// --- End Refactored by {strategy} ---"
            code_to_insert = f"\n{separator_start}\n{refactored_code}\n{separator_end}\n"

            # Step 4: Handle the original method and insert refactored code
            if is_one_to_many:
                # For one-to-many, delete the original method and insert refactored code at the same location
                del lines[start_line : end_line + 1]
                insertion_line = start_line
            else:
                # For one-to-one, comment out the original method and insert refactored code right after it
                for i in range(start_line, end_line + 1):
                    lines[i] = "// " + lines[i]
                insertion_line = end_line + 1
            
            # Insert the new code block
            lines.insert(insertion_line, code_to_insert)
            final_content = '\n'.join(lines)
            
            if debug_mode:
                logger.debug("\n--- Code Validator: Final Content to be Written ---")
                logger.debug(f"File: {test_file_path}")
                logger.debug(f"---\n{final_content}\n---")
                logger.debug("--------------------------------------------------\n")

            # Track inserted lines (simple approach: start and end of insertion)
            inserted_lines_range = list(range(insertion_line, insertion_line + code_to_insert.count('\n')))

            return True, final_content, inserted_lines_range

        except Exception as e:
            logger.error(f"Error integrating refactored method: {e}", exc_info=True)
            return False, original_content, []
    
    def _add_imports(self, content: str, new_imports: List[str]) -> Tuple[str, bool]:
        """Adds new import statements to the Java source code content."""
        lines = content.split('\n')
        
        # Find existing imports
        existing_imports = {line.strip() for line in lines if line.strip().startswith("import ")}
        last_import_line_idx = -1
        package_declaration_idx = -1

        for i, line in enumerate(lines):
            if line.strip().startswith("import "):
                last_import_line_idx = i
            if line.strip().startswith("package "):
                package_declaration_idx = i
        
        # Determine where to insert new imports
        insertion_point = -1
        if last_import_line_idx != -1:
            insertion_point = last_import_line_idx + 1
        elif package_declaration_idx != -1:
            insertion_point = package_declaration_idx + 1
        else:
            # Fallback: insert at the top (after potential license headers)
            for i, line in enumerate(lines):
                if not line.strip().startswith(("/*", "*", "*/", "//")):
                    insertion_point = i
                    break
            if insertion_point == -1: insertion_point = 0

        # Add new imports that don't already exist
        added_count = 0
        for imp in reversed(new_imports):
            full_import_statement = f"import {imp};"
            if full_import_statement not in existing_imports:
                lines.insert(insertion_point, full_import_statement)
                added_count += 1
        
        return '\n'.join(lines), True
    
    def _find_method_span(self, lines: List[str], method_name: str) -> Tuple[int, int]:
        """Finds the start and end line numbers of a method, including its annotations."""
        method_line_idx = -1
        # A simple regex to find method declarations, ignoring complex cases for now
        method_pattern = re.compile(r'\b' + re.escape(method_name) + r'\s*\(')

        for i, line in enumerate(lines):
            if method_pattern.search(line):
                method_line_idx = i
                break
        
        if method_line_idx == -1:
            logger.debug(f"Could not find method declaration for '{method_name}'")
            return -1, -1

        # Find the start of the method's annotations by looking backwards
        start_line = method_line_idx
        for i in range(method_line_idx - 1, -1, -1):
            line = lines[i].strip()
            # Stop if we hit something that's clearly not an annotation or comment
            if line and not line.startswith("@") and not line.startswith("/*") and not line.startswith("*"):
                break
            start_line = i
        
        # Find the end of the method using brace counting
        brace_count = 0
        end_line = -1
        in_method_body = False
        for i in range(method_line_idx, len(lines)):
            line = lines[i]
            if '{' in line:
                if not in_method_body:
                    # This is the start of the body
                    in_method_body = True
                brace_count += line.count('{')
            
            if '}' in line and in_method_body:
                brace_count -= line.count('}')
            
            if in_method_body and brace_count == 0:
                end_line = i
                break
        
        return start_line, end_line

    def _comment_out_method(self, content: str, method_name: str) -> Tuple[str, bool]:
        """Comments out a method and its preceding annotations."""
        lines = content.split('\n')
        start_line, end_line = self._find_method_span(lines, method_name)
        
        if start_line == -1 or end_line == -1:
            logger.debug(f"Could not comment out method '{method_name}': span not found.")
            return content, False

        for i in range(start_line, end_line + 1):
            lines[i] = "// " + lines[i]
            
        return '\n'.join(lines), True

    def _delete_method(self, content: str, method_name: str) -> Tuple[str, bool]:
        """Deletes a method and its preceding annotations from the given source code content."""
        lines = content.split('\n')
        start_line, end_line = self._find_method_span(lines, method_name)
        
        if start_line == -1 or end_line == -1:
            logger.debug(f"Could not delete method '{method_name}': span not found.")
            return content, False # Method not found
        
        del lines[start_line : end_line + 1]
        return '\n'.join(lines), True
    
    def _find_class_closing_brace(self, lines: List[str]) -> int:
        """Find the insertion point: the line index of the class's last closing brace."""
        # A simple heuristic: find the last '}' that is not at the start of the line
        # This avoids matching method closing braces in most simple cases.
        # A more robust solution would parse the class structure.
        for i in range(len(lines) - 1, -1, -1):
            if lines[i].strip() == '}':
                return i
        return -1
    
    def compile_java_project(self) -> Tuple[bool, str]:
        """Compile the Java project using the appropriate build system."""
        debug_logger = logging.getLogger('aif')
        
        if debug_logger.isEnabledFor(logging.DEBUG):
            debug_logger.debug(f"Starting project build using {self.build_system.get_build_system_name()}...")
            debug_logger.debug(f"Project path: {self.java_project_path}")
        
        return self.build_system.compile_project()
    
    def run_specific_test(self, test_class: str, test_method: str, test_file_path: Optional[Path] = None) -> Tuple[bool, str]:
        """Run a specific test method using the appropriate build system."""
        debug_logger = logging.getLogger('aif')
        
        if debug_logger.isEnabledFor(logging.DEBUG):
            debug_logger.debug(f"Running test using {self.build_system.get_build_system_name()}: {test_class}.{test_method}")
            debug_logger.debug(f"Project path: {self.java_project_path}")
            if test_file_path:
                debug_logger.debug(f"Test file path: {test_file_path}")
        
        return self.build_system.run_specific_test(test_class, test_method, test_file_path)
    
    def get_build_system_name(self) -> str:
        """Get the name of the build system being used."""
        return self.build_system.get_build_system_name()
    
    def clean_project(self) -> Tuple[bool, str]:
        """Clean the project using the appropriate build system."""
        return self.build_system.clean_project()